## 2단계 - 서비스 리팩터링

### 요구 사항

* 단위 테스트하기 어려운 코드와 단위 테스트 가능한 코드를 분리해 단위 테스트 가능한 코드에 대해 단위 테스트를 구현한다.
* Spring Data JPA 사용 시 spring.jpa.hibernate.ddl-auto=validate 옵션을 필수로 준다.
* 데이터베이스 스키마 변경 및 마이그레이션이 필요하다면 아래 문서를 적극 활용한다.
    * DB도 형상관리를 해보자!
    
### 기능 정리
* Menu
  * 메뉴 상품의 가격을 계산한다
  * 가격이 더 비싼지 확인한다.
  * 가격을 더한다.
  * 메뉴의 가격은 메뉴 상품들 가격의 총합보다 높을 수 없다.
  * 가격은 0원 이상이어야 한다.
* Order
  * 중복된 메뉴가 있으면 주문할 수 없다.
  * 주문을 처리한다.
  * 계산 완료한 주문은 상태를 변경할 수 없다.
* OrderTable
  * 빈 테이블인지 확인한다.
  * 빈 테이블이 아니거나 이미 단체가 지정되었으면 단체지정을 할 수 없다.
  * 두개 미만의 테이블은 단체지정할 수 없다.
  * 단체 지정이 되어있는 테이블은 이용여부를 변경할 수 없다.
  * 반문한 손님의 수가 0보다 작으면 손님의 수를 변경할 수 없다.
  * 빈 테이블이면 방문한 손님의 수를 변경할 수 없다.
  * 주문 테이블 아이디 목록을 조회한다.
  * 중복되거나 등록되지 않은 테이블은 단체지정을 할 수 없다.
* TableGroup
  * 주문테이블을 변경한다.

## 3단계 - 의존성 리팩터링

### 요구 사항

#### 이전 단계에서 객체 지향 설계를 의식하였다면 아래의 문제가 존재한다. 의존성 관점에서 설계를 검토해 본다.

* 메뉴의 이름과 가격이 변경되면 주문 항목도 함께 변경된다. 메뉴 정보가 변경되더라도 주문 항목이 변경되지 않게 구현한다.
* 클래스 간의 방향도 중요하고 패키지 간의 방향도 중요하다. 클래스 사이, 패키지 사이의 의존 관계는 단방향이 되도록 해야 한다.
* 데이터베이스 스키마 변경 및 마이그레이션이 필요하다면 아래 문서를 적극 활용한다.
  * DB도 형상관리를 해보자!
  
### 요구 사항 분석
* 패키지 변경 (menu, order, table)
* 양방향 의존성 확인
  * menu <-----> order
  * order <-----> table
